import simpy
import random
from typing import Optional, Dict, List, Any

from .models import (
    ProcessBlockConfig, ConnectionConfig, SimulationSetup,
    SimulationStepResult, SimulationRunResult, BatchStepResult
)
from . import state_manager
from .state_manager import (
    sim_log, block_pipes, signals, 
    reset_simulation_state, processed_entities_count, block_entity_counts,
    source_entity_request_events, source_entity_generated_counts, source_entity_total_limits,
    set_signal, get_current_signals, wait_for_signal
)
from .entity import Entity, entity_pool, active_entities_registry, get_active_entity_states, get_block_entity_count
from .script_executor import execute_script_line, execute_conditional_branch_script
from .utils import parse_delay_value, get_latest_movement_description

async def run_simulation(setup: SimulationSetup) -> SimulationRunResult:
    """ì „ì²´ ì‹œë®¬ë ˆì´ì…˜ì„ ì‹¤í–‰í•©ë‹ˆë‹¤."""
    global sim_log, processed_entities_count
    
    # ì‹œë®¬ë ˆì´ì…˜ ì´ˆê¸°í™”
    reset_simulation_state()
    
    state_manager.sim_env = simpy.Environment()
    processed_entities_count = 0
    
    # ì´ˆê¸° ì‹ í˜¸ ì„¤ì •
    if setup.initial_signals:
        for signal_name, value in setup.initial_signals.items():
            set_signal(signal_name, value, state_manager.sim_env)
    
    # íŒŒì´í”„ ìƒì„±
    for conn in setup.connections:
        pipe_id = f"{conn.from_block_id}_{conn.from_connector_id}_to_{conn.to_block_id}_{conn.to_connector_id}"
        block_pipes[pipe_id] = simpy.Store(sim_env)
    
    # ë¸”ë¡ë³„ ì…ì¶œë ¥ íŒŒì´í”„ ë§¤í•‘
    in_pipes_map = {}
    out_pipes_map = {}
    
    for block in setup.blocks:
        in_pipes_map[block.id] = []
        out_pipes_map[block.id] = {}
    
    for conn in setup.connections:
        pipe_id = f"{conn.from_block_id}_{conn.from_connector_id}_to_{conn.to_block_id}_{conn.to_connector_id}"
        in_pipes_map[str(conn.to_block_id)].append(pipe_id)
        
        to_block = next((b for b in setup.blocks if str(b.id) == str(conn.to_block_id)), None)
        out_pipes_map[str(conn.from_block_id)][conn.from_connector_id] = {
            'pipe_id': pipe_id,
            'block_id': conn.to_block_id,
            'block_name': to_block.name if to_block else 'Unknown',
            'connector_name': conn.to_connector_id
        }
    
    # ì†ŒìŠ¤ ë¸”ë¡ ì´ë²¤íŠ¸ ì´ˆê¸°í™”
    for block in setup.blocks:
        has_custom_sink = any(action.type == "custom_sink" for action in block.actions)
        if not in_pipes_map[str(block.id)] and not has_custom_sink:
            source_entity_request_events[str(block.id)] = sim_env.event()
            source_entity_generated_counts[str(block.id)] = 0
            source_entity_total_limits[str(block.id)] = setup.initial_entities
            print(f"[INIT] ì†ŒìŠ¤ ë¸”ë¡ {block.id} ({block.name}) ì´ˆê¸°í™”ë¨")
    
    print(f"[INIT] ì´ {len(source_entity_request_events)}ê°œ ì†ŒìŠ¤ ë¸”ë¡ ì´ˆê¸°í™”ë¨")
    
    # ë¸”ë¡ í”„ë¡œì„¸ìŠ¤ë“¤ ì‹œì‘
    for block_config in setup.blocks:
        sim_env.process(block_process(sim_env, block_config, in_pipes_map[str(block_config.id)], out_pipes_map[str(block_config.id)]))
    
    # ì²« ìŠ¤í…ì—ì„œëŠ” ì´ˆê¸° ì—”í‹°í‹° ìƒì„±
    print(f"[INIT] ì²« ìŠ¤í…ì—ì„œ ì†ŒìŠ¤ ë¸”ë¡ ì´ë²¤íŠ¸ íŠ¸ë¦¬ê±° ì‹œì‘")
    for block in setup.blocks:
        if str(block.id) in source_entity_request_events:
            event = source_entity_request_events[str(block.id)]
            print(f"[INIT] ë¸”ë¡ {block.id}: ì´ë²¤íŠ¸ íŠ¸ë¦¬ê±° ì‹œë„")
            event.succeed()
            source_entity_request_events[str(block.id)] = sim_env.event()
            print(f"[INIT] ë¸”ë¡ {block.id}: ì´ë²¤íŠ¸ íŠ¸ë¦¬ê±°ë¨, ìƒˆ ì´ë²¤íŠ¸ ìƒì„±ë¨")
    
    # ì´ë²¤íŠ¸ê°€ ì¦‰ì‹œ ì²˜ë¦¬ë˜ë„ë¡ ìŠ¤ì¼€ì¤„ë§ ê°•ì œ ì‹¤í–‰
    print(f"[INIT] ì´ë²¤íŠ¸ ìŠ¤ì¼€ì¤„ë§ ê°•ì œ ì‹¤í–‰")
    try:
        sim_env.step()
        print(f"[INIT] ì²« ìŠ¤ì¼€ì¤„ë§ ë‹¨ê³„ ì™„ë£Œ, í˜„ì¬ ì‹œê°„: {sim_env.now}")
    except simpy.core.EmptySchedule:
        print(f"[INIT] ìŠ¤ì¼€ì¤„ì´ ë¹„ì–´ìˆìŒ - ì •ìƒ")
    except Exception as e:
        print(f"[INIT] ìŠ¤ì¼€ì¤„ë§ ì˜¤ë¥˜: {e}")
    
    # ì‹œë®¬ë ˆì´ì…˜ ì‹¤í–‰
    def entity_count_monitor(env, target_count):
        while True:
            if processed_entities_count >= target_count:
                break
            yield env.timeout(0.1)
    
    if setup.stop_entities_processed:
        sim_env.process(entity_count_monitor(sim_env, setup.stop_entities_processed))
    
    try:
        if setup.stop_time:
            sim_env.run(until=setup.stop_time)
        else:
            sim_env.run()
    except Exception as e:
        print(f"Simulation ended with exception: {e}")
    
    # ê²°ê³¼ ë°˜í™˜
    return SimulationRunResult(
        message=f"Simulation completed. Processed {processed_entities_count} entities at time {sim_env.now:.2f}",
        log=sim_log,
        total_entities_processed=processed_entities_count,
        final_time=sim_env.now,
        active_entities=get_active_entity_states()
    )

async def step_simulation(setup: Optional[SimulationSetup] = None) -> SimulationStepResult:
    """ë‹¨ì¼ ìŠ¤í… ì‹œë®¬ë ˆì´ì…˜ì„ ì‹¤í–‰í•©ë‹ˆë‹¤."""
    global sim_log
    
    try:
        # ğŸ”¥ ìƒˆë¡œìš´ ì‹œë®¬ë ˆì´ì…˜ ì„¤ì •ì´ ì œê³µëœ ê²½ìš° í™˜ê²½ì„ ì™„ì „íˆ ì¬ìƒì„±
        if setup is not None:
            print(f"[INIT] ìƒˆë¡œìš´ ì‹œë®¬ë ˆì´ì…˜ ì„¤ì •ìœ¼ë¡œ í™˜ê²½ ì¬ìƒì„±")
            reset_simulation_state()
            
            # ğŸ”¥ SimPy í™˜ê²½ì„ ì™„ì „íˆ ìƒˆë¡œ ìƒì„± (ì‹œê°„ 0ë¶€í„° ì‹œì‘)
            state_manager.sim_env = simpy.Environment()
            print(f"[INIT] ìƒˆë¡œìš´ SimPy í™˜ê²½ ìƒì„±ë¨ (ì‹œê°„: {state_manager.sim_env.now})")
            
            # ì‹œë®¬ë ˆì´ì…˜ ì„¤ì • ì‹¤í–‰
            await run_simulation_setup_for_step(setup)
            print(f"[INIT] ì‹œë®¬ë ˆì´ì…˜ ì„¤ì • ì™„ë£Œ, í˜„ì¬ ì‹œê°„: {state_manager.sim_env.now}")
        
        # í™˜ê²½ì´ ì—†ìœ¼ë©´ ì˜¤ë¥˜
        if state_manager.sim_env is None:
            raise RuntimeError("ì‹œë®¬ë ˆì´ì…˜ í™˜ê²½ì´ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. setupì„ ì œê³µí•´ì£¼ì„¸ìš”.")
        
        # í˜„ì¬ ì‹œê°„ ì €ì¥
        current_time = state_manager.sim_env.now
        
        # í•œ ìŠ¤í… ì‹¤í–‰
        if len(state_manager.sim_env._queue) == 0:
            print("[STEP] ìŠ¤ì¼€ì¤„ ë¹„ì–´ìˆìŒ - ì‹œë®¬ë ˆì´ì…˜ ì™„ë£Œ")
            return SimulationStepResult(
                time=current_time,
                event_description="ì‹œë®¬ë ˆì´ì…˜ ì™„ë£Œ",
                active_entities=[],
                entities_processed_total=processed_entities_count,
                current_signals=get_current_signals()
            )
        
        # ë‹¤ìŒ ì´ë²¤íŠ¸ê¹Œì§€ ì‹¤í–‰
        state_manager.sim_env.step()
        
        # ì‹œê°„ ë³€í™” í™•ì¸
        new_time = sim_env.now
        print(f"[STEP] ìŠ¤í… ì‹¤í–‰ ì™„ë£Œ, ì‹œê°„: {current_time} -> {new_time}")
        
        # ğŸ”¥ ì‹œê°„ì´ ì§„í–‰ëœ ê²½ìš°ì—ë§Œ ì†ŒìŠ¤ ë¸”ë¡ ì´ë²¤íŠ¸ íŠ¸ë¦¬ê±°
        if new_time > current_time:
            print(f"[STEP] ì‹œê°„ {new_time}ì—ì„œ ì†ŒìŠ¤ ë¸”ë¡ ì´ë²¤íŠ¸ íŠ¸ë¦¬ê±° ì‹œë„")
            
            # ê° ì†ŒìŠ¤ ë¸”ë¡ì˜ ì´ë²¤íŠ¸ íŠ¸ë¦¬ê±°
            for block_id, event in source_entity_request_events.items():
                if not event.triggered:
                    print(f"[STEP] ë¸”ë¡ {block_id}: ì´ë²¤íŠ¸ ìƒíƒœ - triggered: {event.triggered}")
                    print(f"[STEP] ë¸”ë¡ {block_id}: ìƒˆ ì´ë²¤íŠ¸ íŠ¸ë¦¬ê±°ë¨")
                    event.succeed()
                    
                    # ìƒˆ ì´ë²¤íŠ¸ ìƒì„±
                    source_entity_request_events[block_id] = sim_env.event()
                else:
                    print(f"[STEP] ë¸”ë¡ {block_id}: ì´ë²¤íŠ¸ ì´ë¯¸ íŠ¸ë¦¬ê±°ë¨")
        else:
            print(f"[STEP] ì‹œê°„ì´ ì§„í–‰ë˜ì§€ ì•ŠìŒ ({current_time} -> {new_time}) - ì†ŒìŠ¤ ì´ë²¤íŠ¸ íŠ¸ë¦¬ê±° ê±´ë„ˆëœ€")
        
        # ì—”í‹°í‹° ìƒíƒœ ë° ì´ë²¤íŠ¸ ì„¤ëª… ìƒì„±
        entity_states = get_active_entity_states()
        event_desc = get_latest_movement_description()
        
        return SimulationStepResult(
            time=new_time,
            event_description=event_desc or f"ì‹œê°„ {new_time}ì—ì„œ ì‹œë®¬ë ˆì´ì…˜ ìŠ¤í… ì™„ë£Œ",
            active_entities=entity_states,
            entities_processed_total=processed_entities_count,
            current_signals=get_current_signals()
        )
        
    except Exception as e:
        print(f"[ERROR] ìŠ¤í… ì‹¤í–‰ ì¤‘ ì˜¤ë¥˜: {e}")
        import traceback
        traceback.print_exc()
        return SimulationStepResult(
            time=sim_env.now if sim_env else 0,
            event_description=f"ì˜¤ë¥˜: {str(e)}",
            active_entities=[],
            entities_processed_total=processed_entities_count,
            current_signals=get_current_signals()
        )

async def batch_step_simulation(steps: int) -> BatchStepResult:
    """ì—¬ëŸ¬ ìŠ¤í…ì„ ì—°ì†ìœ¼ë¡œ ì‹¤í–‰í•©ë‹ˆë‹¤."""
    global sim_env, processed_entities_count
    
    if not sim_env:
        raise ValueError("No active simulation. Please start simulation first.")
    
    initial_log_count = len(sim_log)
    executed_steps = 0
    
    for i in range(steps):
        try:
            sim_env.step()
            executed_steps += 1
        except simpy.core.EmptySchedule:
            break
    
    # ìµœì¢… ì´ë²¤íŠ¸ ì„¤ëª…
    final_description = get_latest_movement_description()
    
    return BatchStepResult(
        message=f"{executed_steps} ìŠ¤í… ì‹¤í–‰ ì™„ë£Œ",
        steps_executed=executed_steps,
        final_event_description=final_description,
        log=sim_log[initial_log_count:],
        current_time=sim_env.now,
        active_entities=get_active_entity_states(),
        total_entities_processed=processed_entities_count
    )

async def run_simulation_setup_for_step(setup: SimulationSetup) -> Optional[SimulationStepResult]:
    """ìŠ¤í… ì‹¤í–‰ì„ ìœ„í•œ ì‹œë®¬ë ˆì´ì…˜ ì´ˆê¸° ì„¤ì •"""
    global sim_env, sim_log, processed_entities_count
    
    # ì‹œë®¬ë ˆì´ì…˜ ì´ˆê¸°í™”
    reset_simulation_state()
    
    sim_env = simpy.Environment()
    processed_entities_count = 0
    
    # ì´ˆê¸° ì‹ í˜¸ ì„¤ì •
    if setup.initial_signals:
        for signal_name, value in setup.initial_signals.items():
            set_signal(signal_name, value, sim_env)
    
    # íŒŒì´í”„ ìƒì„±
    for conn in setup.connections:
        pipe_id = f"{conn.from_block_id}_{conn.from_connector_id}_to_{conn.to_block_id}_{conn.to_connector_id}"
        block_pipes[pipe_id] = simpy.Store(sim_env)
    
    # ë¸”ë¡ë³„ ì…ì¶œë ¥ íŒŒì´í”„ ë§¤í•‘ (ì™„ì „íˆ êµ¬ì„±)
    in_pipes_map = {}
    out_pipes_map = {}
    
    for block in setup.blocks:
        in_pipes_map[block.id] = []
        out_pipes_map[block.id] = {}
    
    for conn in setup.connections:
        pipe_id = f"{conn.from_block_id}_{conn.from_connector_id}_to_{conn.to_block_id}_{conn.to_connector_id}"
        in_pipes_map[str(conn.to_block_id)].append(pipe_id)
        
        to_block = next((b for b in setup.blocks if str(b.id) == str(conn.to_block_id)), None)
        out_pipes_map[str(conn.from_block_id)][conn.from_connector_id] = {
            'pipe_id': pipe_id,
            'block_id': conn.to_block_id,
            'block_name': to_block.name if to_block else 'Unknown',
            'connector_name': conn.to_connector_id
        }
    
    # ì†ŒìŠ¤ ë¸”ë¡ ì´ë²¤íŠ¸ ì´ˆê¸°í™”
    for block in setup.blocks:
        has_custom_sink = any(action.type == "custom_sink" for action in block.actions)
        if not in_pipes_map[str(block.id)] and not has_custom_sink:
            source_entity_request_events[str(block.id)] = sim_env.event()
            source_entity_generated_counts[str(block.id)] = 0
            source_entity_total_limits[str(block.id)] = setup.initial_entities
            print(f"[INIT] ì†ŒìŠ¤ ë¸”ë¡ {block.id} ({block.name}) ì´ˆê¸°í™”ë¨")
    
    print(f"[INIT] ì´ {len(source_entity_request_events)}ê°œ ì†ŒìŠ¤ ë¸”ë¡ ì´ˆê¸°í™”ë¨")
    
    # ë¸”ë¡ í”„ë¡œì„¸ìŠ¤ë“¤ ì‹œì‘
    for block_config in setup.blocks:
        sim_env.process(block_process(sim_env, block_config, in_pipes_map[str(block_config.id)], out_pipes_map[str(block_config.id)]))
    
    # ì²« ìŠ¤í…ì—ì„œëŠ” ì´ˆê¸° ì—”í‹°í‹° ìƒì„±
    print(f"[INIT] ì²« ìŠ¤í…ì—ì„œ ì†ŒìŠ¤ ë¸”ë¡ ì´ë²¤íŠ¸ íŠ¸ë¦¬ê±° ì‹œì‘")
    for block in setup.blocks:
        if str(block.id) in source_entity_request_events:
            event = source_entity_request_events[str(block.id)]
            print(f"[INIT] ë¸”ë¡ {block.id}: ì´ë²¤íŠ¸ íŠ¸ë¦¬ê±° ì‹œë„")
            event.succeed()
            source_entity_request_events[str(block.id)] = sim_env.event()
            print(f"[INIT] ë¸”ë¡ {block.id}: ì´ë²¤íŠ¸ íŠ¸ë¦¬ê±°ë¨, ìƒˆ ì´ë²¤íŠ¸ ìƒì„±ë¨")
    
    # ì´ë²¤íŠ¸ê°€ ì¦‰ì‹œ ì²˜ë¦¬ë˜ë„ë¡ ìŠ¤ì¼€ì¤„ë§ ê°•ì œ ì‹¤í–‰
    print(f"[INIT] ì´ë²¤íŠ¸ ìŠ¤ì¼€ì¤„ë§ ê°•ì œ ì‹¤í–‰")
    try:
        sim_env.step()
        print(f"[INIT] ì²« ìŠ¤ì¼€ì¤„ë§ ë‹¨ê³„ ì™„ë£Œ, í˜„ì¬ ì‹œê°„: {sim_env.now}")
    except simpy.core.EmptySchedule:
        print(f"[INIT] ìŠ¤ì¼€ì¤„ì´ ë¹„ì–´ìˆìŒ - ì •ìƒ")
    except Exception as e:
        print(f"[INIT] ìŠ¤ì¼€ì¤„ë§ ì˜¤ë¥˜: {e}")
    
    # ì´ˆê¸° ì„¤ì • ë‹¨ê³„ì´ë¯€ë¡œ Noneì„ ë°˜í™˜í•˜ì—¬ ì •ìƒì ì¸ ìŠ¤í… ì‹¤í–‰ì´ ê³„ì†ë˜ë„ë¡ í•¨
    return None

def block_process(env: simpy.Environment, block_config: ProcessBlockConfig, in_pipe_ids: List[str], out_pipe_connectors: Dict[str, str]):
    """ë¸”ë¡ í”„ë¡œì„¸ìŠ¤ì˜ í•µì‹¬ ë¡œì§ (ì›ë³¸ì—ì„œ ì¶”ì¶œ)"""
    global processed_entities_count, sim_log, signals, block_pipes, active_entities_registry
    global source_entity_request_events, source_entity_generated_counts 
    
    block_log_prefix = f"BPROC [{block_config.name}({block_config.id})]"
    print(f"{env.now:.2f}: {block_log_prefix} Process started. Inputs: {in_pipe_ids}, Outputs: {out_pipe_connectors}")
    sim_log.append({"time": env.now, "event": f"{block_log_prefix} process started."})

    # custom_sink ì•¡ì…˜ì´ ìˆëŠ” ë¸”ë¡ì€ ì‹±í¬ ë¸”ë¡ìœ¼ë¡œ ê°„ì£¼
    has_custom_sink = any(action.type == "custom_sink" for action in block_config.actions)
    is_source_block = not in_pipe_ids and not has_custom_sink
    
    print(f"{env.now:.2f}: {block_log_prefix} Block analysis - Has input pipes: {bool(in_pipe_ids)}, Has custom_sink: {has_custom_sink}, Is source: {is_source_block}")

    while True:
        entity: Optional[Entity] = None
        print(f"{env.now:.2f}: {block_log_prefix} New loop iteration. Is source: {is_source_block}")

        # ì—”í‹°í‹° íšë“ ë¡œì§ (ì†ŒìŠ¤/ì‹±í¬/ì¼ë°˜ ë¸”ë¡ë³„ ì²˜ë¦¬)
        entity = yield from get_entity_for_block(env, block_config, is_source_block, has_custom_sink, in_pipe_ids, block_log_prefix)
        
        if not entity:
            print(f"{env.now:.2f}: {block_log_prefix} No entity to process this iteration.")
            yield env.timeout(0.0001)
            continue

        # ì•¡ì…˜ ì‹¤í–‰
        yield from execute_block_actions(env, block_config, entity, out_pipe_connectors, block_log_prefix)

def get_entity_for_block(env, block_config, is_source_block, has_custom_sink, in_pipe_ids, block_log_prefix):
    """ë¸”ë¡ íƒ€ì…ì— ë”°ë¼ ì—”í‹°í‹°ë¥¼ íšë“í•©ë‹ˆë‹¤."""
    if is_source_block:
        return (yield from get_source_entity(env, block_config, block_log_prefix))
    elif has_custom_sink or in_pipe_ids:
        return (yield from get_pipe_entity(env, block_config, in_pipe_ids, block_log_prefix))
    else:
        print(f"{env.now:.2f}: {block_log_prefix} No valid input method. Idling.")
        yield env.timeout(1)
        return None

def get_source_entity(env, block_config, block_log_prefix):
    """ì†ŒìŠ¤ ë¸”ë¡ì—ì„œ ì—”í‹°í‹°ë¥¼ ìƒì„±í•©ë‹ˆë‹¤."""
    block_id_str = str(block_config.id)  # ë¬¸ìì—´ë¡œ ë³€í™˜
    if block_id_str not in source_entity_request_events:
        print(f"{env.now:.2f}: {block_log_prefix} Critical Error: source_entity_request_event not initialized.")
        yield env.timeout(float('inf'))
        return None

    current_total_generated = source_entity_generated_counts.get(block_id_str, 0)
    print(f"{env.now:.2f}: {block_log_prefix} Source block. Total generated so far: {current_total_generated}.")
    
    # ğŸ”¥ ìš©ëŸ‰ ì²´í¬ ì¶”ê°€ - ì†ŒìŠ¤ ë¸”ë¡ë„ ìš©ëŸ‰ ì œí•œ í™•ì¸
    current_entity_count = block_entity_counts.get(block_config.id, 0)
    max_capacity = getattr(block_config, 'maxCapacity', None) or getattr(block_config, 'capacity', None)
    
    if max_capacity is not None and current_entity_count >= max_capacity:
        print(f"{env.now:.2f}: {block_log_prefix} Source block at capacity ({current_entity_count}/{max_capacity}). Cannot generate new entity.")
        sim_log.append({"time": env.now, "block_id": block_config.id, "event": f"Source {block_config.name} at capacity ({current_entity_count}/{max_capacity}), generation blocked"})
        yield env.timeout(1.0)  # 1ì´ˆ ëŒ€ê¸° í›„ ì¬ì‹œë„
        return None
    
    # ì²« ë²ˆì§¸ ì—”í‹°í‹°ëŠ” ì¦‰ì‹œ ìƒì„± (ì‹œê°„ 0ì—ì„œ)
    if current_total_generated == 0 and env.now == 0:
        print(f"{env.now:.2f}: {block_log_prefix} First entity - generating immediately.")
    else:
        # ë‘ ë²ˆì§¸ ì—”í‹°í‹°ë¶€í„°ëŠ” ì´ë²¤íŠ¸ ëŒ€ê¸°
        try:
            print(f"{env.now:.2f}: {block_log_prefix} Waiting for entity request event...")
            yield source_entity_request_events[block_id_str]
            print(f"{env.now:.2f}: {block_log_prefix} Entity request event received.")
        except Exception as e:
            print(f"{env.now:.2f}: {block_log_prefix} Exception waiting for request event: {e}.")
            yield env.timeout(0.000001)
            return None
    
    # ğŸ”¥ ì—”í‹°í‹° ìƒì„± ì „ ìš©ëŸ‰ ì¬í™•ì¸ (ì´ë²¤íŠ¸ ëŒ€ê¸° ì¤‘ ìƒí™©ì´ ë³€í•  ìˆ˜ ìˆìŒ)
    current_entity_count = block_entity_counts.get(block_config.id, 0)
    if max_capacity is not None and current_entity_count >= max_capacity:
        print(f"{env.now:.2f}: {block_log_prefix} Source block capacity limit reached after wait ({current_entity_count}/{max_capacity}). Skipping generation.")
        yield env.timeout(0.1)  # ì§§ì€ ëŒ€ê¸° í›„ ë‹¤ì‹œ ì‹œë„
        return None
    
    # ì—”í‹°í‹° ìƒì„± (Entity í´ë˜ìŠ¤ê°€ ìë™ìœ¼ë¡œ ì¹´ìš´íŠ¸ ê´€ë¦¬)
    entity_id_str = f"{block_config.id}-e{current_total_generated + 1}"
    entity = entity_pool.get_entity(env, entity_id_str)
    entity.update_location(block_config.id, block_config.name)
    
    # ğŸ”¥ ìˆ˜ë™ ì¹´ìš´íŠ¸ ì¡°ì‘ ì œê±° - Entity í´ë˜ìŠ¤ê°€ ìë™ ê´€ë¦¬
    current_entity_count = block_entity_counts.get(block_config.id, 0)
    print(f"{env.now:.2f}: {block_log_prefix} Generated Entity {entity.id} (capacity: {current_entity_count}/{max_capacity})")
    sim_log.append({"time": env.now, "entity_id": entity.id, "event": f"Entity {entity.id} generated at Source {block_config.name}"})
    
    source_entity_generated_counts[block_id_str] = current_total_generated + 1
    return entity

def get_pipe_entity(env, block_config, in_pipe_ids, block_log_prefix):
    """íŒŒì´í”„ì—ì„œ ì—”í‹°í‹°ë¥¼ íšë“í•©ë‹ˆë‹¤."""
    # ì—¬ëŸ¬ ì…ë ¥ íŒŒì´í”„ê°€ ìˆëŠ” ê²½ìš° ìš°ì„ ìˆœìœ„ëŒ€ë¡œ ì²´í¬
    for pipe_id in in_pipe_ids:
        pipe = block_pipes.get(pipe_id)
        if pipe and len(pipe.items) > 0:
            print(f"{env.now:.2f}: {block_log_prefix} Waiting for entity from pipe '{pipe_id}'")
            entity = yield pipe.get()
            
            # ğŸ”¥ ìˆ˜ìš©ëŸ‰ ì²´í¬ - ë¸”ë¡ì´ ê°€ë“ ì°¬ ê²½ìš° ì—”í‹°í‹°ë¥¼ ë°›ì§€ ì•ŠìŒ
            current_count = get_block_entity_count(block_config.id)
            max_capacity = getattr(block_config, 'maxCapacity', None) or getattr(block_config, 'capacity', None)
            
            if max_capacity is not None and current_count >= max_capacity:
                print(f"{env.now:.2f}: {block_log_prefix} Block at capacity ({current_count}/{max_capacity}), entity blocked")
                # ì—”í‹°í‹°ë¥¼ ë‹¤ì‹œ íŒŒì´í”„ì— ë„£ì–´ì„œ ë‚˜ì¤‘ì— ì²˜ë¦¬
                yield pipe.put(entity)
                yield env.timeout(0.1)  # ì§§ì€ ëŒ€ê¸° í›„ ë‹¤ì‹œ ì‹œë„
                continue
            
            print(f"{env.now:.2f}: {block_log_prefix} Received Entity {entity.id} (capacity: {current_count + 1}/{max_capacity or 'None'})")
            
            # ğŸ”¥ ì—”í‹°í‹° ìœ„ì¹˜ë¥¼ í˜„ì¬ ë¸”ë¡ìœ¼ë¡œ ì—…ë°ì´íŠ¸
            entity.update_location(block_config.id, block_config.name)
            
            # ì»¤ë„¥í„° ì•¡ì…˜ì´ ìˆìœ¼ë©´ ë¨¼ì € ì‹¤í–‰
            yield from execute_connector_actions(env, block_config, entity, pipe_id, block_log_prefix)
            
            return entity
    
    # ëª¨ë“  íŒŒì´í”„ê°€ ë¹„ì–´ìˆê±°ë‚˜ ìˆ˜ìš©ëŸ‰ ì´ˆê³¼ì¸ ê²½ìš°
    print(f"{env.now:.2f}: {block_log_prefix} Waiting for entity from pipe '{in_pipe_ids[0] if in_pipe_ids else 'unknown'}'")
    entity = yield block_pipes[in_pipe_ids[0]].get()
    
    # ğŸ”¥ ìˆ˜ìš©ëŸ‰ ì¬ì²´í¬
    current_count = get_block_entity_count(block_config.id)
    max_capacity = getattr(block_config, 'maxCapacity', None) or getattr(block_config, 'capacity', None)
    
    if max_capacity is not None and current_count >= max_capacity:
        print(f"{env.now:.2f}: {block_log_prefix} Block still at capacity, waiting...")
        yield block_pipes[in_pipe_ids[0]].put(entity)
        yield env.timeout(0.1)
        return None
    
    print(f"{env.now:.2f}: {block_log_prefix} Received Entity {entity.id} (capacity: {current_count + 1}/{max_capacity or 'None'})")
    
    # ğŸ”¥ ì—”í‹°í‹° ìœ„ì¹˜ë¥¼ í˜„ì¬ ë¸”ë¡ìœ¼ë¡œ ì—…ë°ì´íŠ¸
    entity.update_location(block_config.id, block_config.name)
    
    # ì»¤ë„¥í„° ì•¡ì…˜ì´ ìˆìœ¼ë©´ ë¨¼ì € ì‹¤í–‰
    yield from execute_connector_actions(env, block_config, entity, in_pipe_ids[0], block_log_prefix)
    
    return entity

def execute_connector_actions(env, block_config, entity, arrival_pipe_id, block_log_prefix):
    """ë„ì°©í•œ ì»¤ë„¥í„°ì˜ ì•¡ì…˜ë“¤ì„ ì‹¤í–‰í•©ë‹ˆë‹¤."""
    # ë„ì°©í•œ íŒŒì´í”„ì— í•´ë‹¹í•˜ëŠ” ì»¤ë„¥í„° ì°¾ê¸°
    target_connector = None
    if hasattr(block_config, 'connectionPoints') and block_config.connectionPoints:
        for connector in block_config.connectionPoints:
            # íŒŒì´í”„ ID í˜•íƒœ: "1_1-conn-right_to_2_2-conn-left"
            # ì»¤ë„¥í„° IDê°€ íŒŒì´í”„ IDì— í¬í•¨ë˜ëŠ”ì§€ í™•ì¸
            if arrival_pipe_id.endswith(f"to_{block_config.id}_{connector.id}"):
                target_connector = connector
                break
    
    if not target_connector:
        print(f"{env.now:.2f}: {block_log_prefix} No actions in connector {arrival_pipe_id}")
        return
    
    if not hasattr(target_connector, 'actions') or not target_connector.actions:
        print(f"{env.now:.2f}: {block_log_prefix} No actions in connector {target_connector.id}")
        return
    
    # ì»¤ë„¥í„° ì•¡ì…˜ ì‹¤í–‰
    connector_log_prefix = f"{block_log_prefix} [Connector:{target_connector.id}] [E:{entity.id}]"
    
    # ğŸ”¥ ì¤‘ìš”: ì»¤ë„¥í„° ì•¡ì…˜ ì‹¤í–‰ ì¤‘ì—ëŠ” ì—”í‹°í‹°ê°€ ì—¬ì „íˆ í˜„ì¬ ë¸”ë¡ì— ìœ„ì¹˜í•¨ì„ ë³´ì¥
    print(f"{env.now:.2f}: {connector_log_prefix} Starting connector actions (entity remains in block {block_config.name})")
    
    # ğŸ”¥ ì—”í‹°í‹° ìœ„ì¹˜ë¥¼ ëª…ì‹œì ìœ¼ë¡œ í˜„ì¬ ë¸”ë¡ìœ¼ë¡œ ì„¤ì • (í™”ë©´ í‘œì‹œìš©)
    entity.update_location(block_config.id, block_config.name)
    
    for action in target_connector.actions:
        print(f"{env.now:.2f}: {connector_log_prefix} Executing connector action: {action.name} ({action.type})")
        
        if action.type == "conditional_branch":
            script = action.parameters.get("script", "")
            if script:
                act_log = []
                yield from execute_conditional_branch_script(env, script, entity, act_log, {})
                
                # ğŸ”¥ ì¤‘ìš”: ì»¤ë„¥í„°ì—ì„œ ê°™ì€ ë¸”ë¡ìœ¼ë¡œ ì´ë™í•˜ëŠ” ê²½ìš° ì²´í¬ (ë” ì •í™•í•œ ë§¤ì¹­)
                self_move_detected = any("moving to same block's main process" in log.lower() for log in act_log)
                print(f"{env.now:.2f}: {connector_log_prefix} Act log contents: {act_log}")
                print(f"{env.now:.2f}: {connector_log_prefix} Self move detected: {self_move_detected}")
                
                if self_move_detected:
                    print(f"{env.now:.2f}: {connector_log_prefix} Entity stays in same block - no location change needed")
                    # ğŸ”¥ ì—”í‹°í‹° ìœ„ì¹˜ í™•ì‹¤íˆ ìœ ì§€
                    entity.update_location(block_config.id, block_config.name)
                    # ì»¤ë„¥í„° ì•¡ì…˜ ì™„ë£Œ, ì—”í‹°í‹°ëŠ” ê³„ì† ê°™ì€ ë¸”ë¡ì—ì„œ ë¸”ë¡ ì•¡ì…˜ ì§„í–‰
                    return
                    
                # ë‹¤ë¥¸ ë¸”ë¡ìœ¼ë¡œ ì´ë™í•œ ê²½ìš°ë§Œ ë°˜í™˜
                external_move_detected = any("moved to" in log.lower() and "same block" not in log.lower() for log in act_log)
                if external_move_detected:
                    print(f"{env.now:.2f}: {connector_log_prefix} Entity moved to different block")
                    return
        
        elif action.type == "signal_wait":
            # ì‹ í˜¸ ëŒ€ê¸° ì•¡ì…˜ (ì—”í‹°í‹°ëŠ” ì—¬ì „íˆ ê°™ì€ ë¸”ë¡ì— ìˆìŒ)
            signal_name = action.parameters.get("signal_name")
            expected_value = action.parameters.get("expected_value", True)
            
            if signal_name:
                # ğŸ”¥ ë¨¼ì € í˜„ì¬ ì‹ í˜¸ ê°’ í™•ì¸í•˜ì—¬ ì¦‰ì‹œ ì²˜ë¦¬ ê°€ëŠ¥í•œì§€ í™•ì¸
                current_signals = get_current_signals()
                if current_signals.get(signal_name, False) == expected_value:
                    # ì´ë¯¸ ì›í•˜ëŠ” ê°’ì´ë©´ ì¦‰ì‹œ ì§„í–‰
                    print(f"{env.now:.2f}: {connector_log_prefix} Signal '{signal_name}' already {expected_value} - proceeding immediately (entity in {block_config.name})")
                else:
                    # ì›í•˜ëŠ” ê°’ì´ ì•„ë‹ˆë©´ ëŒ€ê¸°
                    print(f"{env.now:.2f}: {connector_log_prefix} Waiting for signal '{signal_name}' = {expected_value} (entity in {block_config.name})")
                    # ğŸ”¥ ì—”í‹°í‹° ìœ„ì¹˜ë¥¼ í™•ì‹¤íˆ ìœ ì§€
                    entity.update_location(block_config.id, block_config.name)
                    yield wait_for_signal(signal_name, expected_value, env)
                    print(f"{env.now:.2f}: {connector_log_prefix} Signal '{signal_name}' received")
        
        elif action.type == "signal_update":
            # ì‹ í˜¸ ì—…ë°ì´íŠ¸ ì•¡ì…˜ (ì—”í‹°í‹°ëŠ” ì—¬ì „íˆ ê°™ì€ ë¸”ë¡ì— ìˆìŒ)
            signal_name = action.parameters.get("signal_name")
            value = action.parameters.get("value", False)
            
            if signal_name:
                set_signal(signal_name, value, env)
                print(f"{env.now:.2f}: {connector_log_prefix} Signal '{signal_name}' set to {value}")
        
        elif action.type == "route_to_connector":
            # ë‹¤ë¥¸ ë¸”ë¡ìœ¼ë¡œ ë¼ìš°íŒ… ì•¡ì…˜
            delay = action.parameters.get("delay", "0")
            target_block_id = action.parameters.get("target_block_id")
            target_connector_id = action.parameters.get("target_connector_id")
            
            # ë”œë ˆì´ ì²˜ë¦¬ (ì—”í‹°í‹°ëŠ” ì•„ì§ í˜„ì¬ ë¸”ë¡ì— ìˆìŒ)
            if delay and delay != "0":
                delay_time = parse_delay_value(str(delay))
                print(f"{env.now:.2f}: {connector_log_prefix} Delaying for {delay_time}s before routing (entity in {block_config.name})")
                # ğŸ”¥ ë”œë ˆì´ ì¤‘ì—ë„ ì—”í‹°í‹° ìœ„ì¹˜ ìœ ì§€
                entity.update_location(block_config.id, block_config.name)
                yield env.timeout(delay_time)
            
            # ğŸ”¥ ë¼ìš°íŒ… ì²˜ë¦¬ - ì´ë•Œë§Œ ì—”í‹°í‹° ìœ„ì¹˜ë¥¼ ë³€ê²½
            if target_block_id and target_connector_id:
                pipe_id = f"{block_config.id}_{target_connector.id}_to_{target_block_id}_{target_connector_id}"
                
                if pipe_id in block_pipes:
                    # ğŸ”¥ ì—”í‹°í‹°ê°€ ì‹¤ì œë¡œ ë‹¤ë¥¸ ë¸”ë¡ìœ¼ë¡œ ì´ë™í•  ë•Œë§Œ transit ìƒíƒœë¡œ ë³€ê²½
                    print(f"{env.now:.2f}: {connector_log_prefix} Connector actions completed - now routing to different block")
                    
                    yield block_pipes[pipe_id].put(entity)
                    target_block_name = action.parameters.get("target_block_name", f"Block {target_block_id}")
                    print(f"{env.now:.2f}: {block_log_prefix} [E:{entity.id}] Routed to {target_block_name}")
                    sim_log.append({"time": env.now, "entity_id": entity.id, "event": f"Entity {entity.id} routed from {block_config.name} to {target_block_name}"})
                    return  # ì—”í‹°í‹°ê°€ ë‹¤ë¥¸ ë¸”ë¡ìœ¼ë¡œ ì´ë™í–ˆìœ¼ë¯€ë¡œ ë°˜í™˜
                else:
                    # ğŸ”¥ íŒŒì´í”„ê°€ ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ê²½ìš° ì˜¤ë¥˜ ì²˜ë¦¬
                    print(f"{env.now:.2f}: {connector_log_prefix} ERROR: Pipe {pipe_id} not found. Available pipes: {list(block_pipes.keys())}")
                    print(f"{env.now:.2f}: {connector_log_prefix} Routing failed - entity remains in current block")
                    return
    
    print(f"{env.now:.2f}: {connector_log_prefix} All connector actions completed (entity remains in {block_config.name})")

def execute_block_actions(env, block_config, entity, out_pipe_connectors, block_log_prefix):
    """ë¸”ë¡ì˜ ì•¡ì…˜ë“¤ì„ ì‹¤í–‰í•©ë‹ˆë‹¤."""
    global processed_entities_count
    
    entity_log_prefix = f"{block_log_prefix} [E:{entity.id}]"
    current_action_index = 0
    
    while current_action_index < len(block_config.actions):
        action = block_config.actions[current_action_index]
        print(f"{env.now:.2f}: {entity_log_prefix} Executing action: {action.name} ({action.type})")
        
        # ì•¡ì…˜ ì‹¤í–‰
        result = yield from execute_single_action(env, action, entity, out_pipe_connectors, entity_log_prefix, block_config)
        
        if result == 'route_out':
            # ì—”í‹°í‹°ê°€ ë‹¤ë¥¸ ë¸”ë¡ìœ¼ë¡œ ë¼ìš°íŒ…ë¨
            break
        elif result == 'processed':
            # ì—”í‹°í‹°ê°€ ì²˜ë¦¬ë¨ (ì‹±í¬)
            processed_entities_count += 1
            entity_pool.return_entity(entity)
            break
        
        current_action_index += 1

def execute_single_action(env, action, entity, out_pipe_connectors, entity_log_prefix, block_config):
    """ë‹¨ì¼ ì•¡ì…˜ì„ ì‹¤í–‰í•©ë‹ˆë‹¤."""
    act_log = []
    
    if action.type == "delay":
        duration = parse_delay_value(str(action.parameters.get("duration", 0)))
        if duration > 0:
            yield env.timeout(duration)
        else:
            yield env.timeout(0.00001)
        print(f"{env.now:.2f}: {entity_log_prefix} Delayed for {duration}s.")
    
    elif action.type == "custom_sink":
        # ğŸ”¥ Entity í´ë˜ìŠ¤ì˜ remove()ê°€ ìë™ìœ¼ë¡œ ì¹´ìš´íŠ¸ ê°ì†Œ
        print(f"{env.now:.2f}: {entity_log_prefix} Processed by custom sink.")
        sim_log.append({"time": env.now, "entity_id": entity.id, "event": f"Entity {entity.id} processed by sink"})
        return 'processed'
    
    elif action.type == "route_to_connector":
        connector_id = action.parameters.get("connector_id")
        delay = action.parameters.get("delay", "0")
        
        if delay and delay != "0":
            delay_time = parse_delay_value(str(delay))
            yield env.timeout(delay_time)
        
        if connector_id and connector_id in out_pipe_connectors:
            pipe_info = out_pipe_connectors[connector_id]
            pipe_id = pipe_info.get('pipe_id')
            
            if pipe_id and pipe_id in block_pipes:
                # ê°™ì€ ë¸”ë¡ ë‚´ ì»¤ë„¥í„°ë¡œ ì´ë™í•˜ëŠ” ê²½ìš° ì»¤ë„¥í„° ì•¡ì…˜ ì‹¤í–‰
                target_connector = None
                if hasattr(block_config, 'connectionPoints') and block_config.connectionPoints:
                    for connector in block_config.connectionPoints:
                        if connector.id == connector_id:
                            target_connector = connector
                            break
                
                if target_connector and hasattr(target_connector, 'actions') and target_connector.actions:
                    # ì»¤ë„¥í„° ì•¡ì…˜ë“¤ì„ ì‹¤í–‰
                    connector_log_prefix = f"{entity_log_prefix} [Connector:{target_connector.id}]"
                    print(f"{env.now:.2f}: {connector_log_prefix} Executing connector actions before routing")
                    
                    # ğŸ”¥ ì»¤ë„¥í„° ì•¡ì…˜ ì‹¤í–‰ ì¤‘ì—ëŠ” ì—”í‹°í‹°ê°€ ì—¬ì „íˆ ê°™ì€ ë¸”ë¡ì— ìˆìŒì„ ëª…ì‹œ
                    print(f"{env.now:.2f}: {connector_log_prefix} Entity remains in block {block_config.name} during connector actions")
                    
                    for conn_action in target_connector.actions:
                        print(f"{env.now:.2f}: {connector_log_prefix} Executing: {conn_action.name} ({conn_action.type})")
                        
                        if conn_action.type == "signal_wait":
                            signal_name = conn_action.parameters.get("signal_name")
                            expected_value = conn_action.parameters.get("expected_value", True)
                            if signal_name:
                                # ğŸ”¥ ë¨¼ì € í˜„ì¬ ì‹ í˜¸ ê°’ í™•ì¸í•˜ì—¬ ì¦‰ì‹œ ì²˜ë¦¬ ê°€ëŠ¥í•œì§€ í™•ì¸
                                current_signals = get_current_signals()
                                if current_signals.get(signal_name, False) == expected_value:
                                    # ì´ë¯¸ ì›í•˜ëŠ” ê°’ì´ë©´ ì¦‰ì‹œ ì§„í–‰
                                    print(f"{env.now:.2f}: {connector_log_prefix} Signal '{signal_name}' already {expected_value} - proceeding immediately (entity in {block_config.name})")
                                else:
                                    # ì›í•˜ëŠ” ê°’ì´ ì•„ë‹ˆë©´ ëŒ€ê¸°
                                    print(f"{env.now:.2f}: {connector_log_prefix} Waiting for signal '{signal_name}' = {expected_value} (entity in {block_config.name})")
                                    yield wait_for_signal(signal_name, expected_value, env)
                                    print(f"{env.now:.2f}: {connector_log_prefix} Signal '{signal_name}' received")
                        
                        elif conn_action.type == "signal_update":
                            signal_name = conn_action.parameters.get("signal_name")
                            value = conn_action.parameters.get("value", False)
                            if signal_name:
                                set_signal(signal_name, value, env)
                                print(f"{env.now:.2f}: {connector_log_prefix} Signal '{signal_name}' set to {value}")
                        
                        elif conn_action.type == "route_to_connector":
                            # ì»¤ë„¥í„°ì˜ route_to_connector ì•¡ì…˜ (ë‹¤ë¥¸ ë¸”ë¡ìœ¼ë¡œ ì´ë™)
                            conn_delay = conn_action.parameters.get("delay", "0")
                            if conn_delay and conn_delay != "0":
                                conn_delay_time = parse_delay_value(str(conn_delay))
                                print(f"{env.now:.2f}: {connector_log_prefix} Delaying for {conn_delay_time}s before routing (entity in {block_config.name})")
                                yield env.timeout(conn_delay_time)
                            
                            # ì´ì œ ì‹¤ì œ ë¼ìš°íŒ… ìˆ˜í–‰
                            break  # ë¼ìš°íŒ… ì•¡ì…˜ì„ ë§Œë‚˜ë©´ ì•„ë˜ ë¼ìš°íŒ… ë¡œì§ìœ¼ë¡œ ì§„í–‰
                
                # ğŸ”¥ ëª¨ë“  ì»¤ë„¥í„° ì•¡ì…˜ì´ ì™„ë£Œëœ í›„ ì‹¤ì œë¡œ ë‹¤ë¥¸ ë¸”ë¡ìœ¼ë¡œ ì´ë™í•  ë•Œë§Œ transit ìƒíƒœë¡œ ë³€ê²½
                print(f"{env.now:.2f}: {entity_log_prefix} Connector actions completed - now routing to different block")
                
                # ğŸ”¥ íŒŒì´í”„ ì¡´ì¬ ì—¬ë¶€ í™•ì¸
                if pipe_id not in block_pipes:
                    print(f"{env.now:.2f}: {entity_log_prefix} ERROR: Pipe {pipe_id} not found. Available pipes: {list(block_pipes.keys())}")
                    return 'route_error'
                
                entity.update_location("transit", "In Transit")
                
                yield block_pipes[pipe_id].put(entity)
                print(f"{env.now:.2f}: {entity_log_prefix} Routed to {pipe_info.get('block_name', 'Unknown')}")
                sim_log.append({"time": env.now, "entity_id": entity.id, "event": f"Entity {entity.id} routed out"})
                return 'route_out'
    
    elif action.type == "conditional_branch":
        script = action.parameters.get("script", "")
        if script:
            yield from execute_conditional_branch_script(env, script, entity, act_log, out_pipe_connectors)
            if any("moved to" in log for log in act_log):
                # ğŸ”¥ ìŠ¤í¬ë¦½íŠ¸ë¡œ ì´ë™ì€ ì´ë¯¸ script_executorì—ì„œ ì²˜ë¦¬ë˜ë¯€ë¡œ ì—¬ê¸°ì„œëŠ” ì¹´ìš´íŠ¸ ì²˜ë¦¬ ì•ˆí•¨
                return 'route_out'
    
    return 'continue' 