/**
 * ÌîÑÎ°†Ìä∏ÏóîÎìú ÏÑ±Îä• Î™®ÎãàÌÑ∞ÎßÅ Composable
 * API Ìò∏Ï∂ú, Î†åÎçîÎßÅ, ÏÇ¨Ïö©Ïûê ÏÉÅÌò∏ÏûëÏö©Ïùò ÏÑ±Îä•ÏùÑ Ï∏°Ï†ïÌï©ÎãàÎã§.
 */

import { ref, reactive } from 'vue'

export function usePerformanceMonitor() {
  // ÏÑ±Îä• Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû•ÏÜå
  const performanceData = reactive({
    apiCalls: [],
    renderTimes: [],
    userInteractions: [],
    memoryUsage: [],
    summary: {
      totalApiCalls: 0,
      avgApiTime: 0,
      slowestApi: null,
      totalRenders: 0,
      avgRenderTime: 0,
      totalInteractions: 0,
      avgInteractionTime: 0
    }
  })

  // Î™®ÎãàÌÑ∞ÎßÅ ÏÉÅÌÉú
  const isMonitoring = ref(false)
  const monitoringStartTime = ref(null)

  /**
   * ÏÑ±Îä• Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏûë
   */
  function startMonitoring() {
    console.log('üöÄ [Performance] ÏÑ±Îä• Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏûë')
    isMonitoring.value = true
    monitoringStartTime.value = performance.now()
    
    // Í∏∞Ï°¥ Îç∞Ïù¥ÌÑ∞ Ï¥àÍ∏∞Ìôî
    performanceData.apiCalls.length = 0
    performanceData.renderTimes.length = 0
    performanceData.userInteractions.length = 0
    performanceData.memoryUsage.length = 0
    
    // Î©îÎ™®Î¶¨ ÏÇ¨Ïö©Îüâ Ï£ºÍ∏∞Ï†Å Ï∏°Ï†ï (Î∏åÎùºÏö∞Ï†ÄÏóêÏÑú Í∞ÄÎä•Ìïú Í≤ΩÏö∞)
    if (performance.memory) {
      const memoryInterval = setInterval(() => {
        if (!isMonitoring.value) {
          clearInterval(memoryInterval)
          return
        }
        
        recordMemoryUsage()
      }, 1000) // 1Ï¥àÎßàÎã§ Ï∏°Ï†ï
    }
  }

  /**
   * ÏÑ±Îä• Î™®ÎãàÌÑ∞ÎßÅ Ï§ëÎã®
   */
  function stopMonitoring() {
    console.log('üõë [Performance] ÏÑ±Îä• Î™®ÎãàÌÑ∞ÎßÅ Ï§ëÎã®')
    isMonitoring.value = false
    updateSummary()
    
    const monitoringDuration = performance.now() - monitoringStartTime.value
    console.log(`üìä [Performance] Î™®ÎãàÌÑ∞ÎßÅ Í∏∞Í∞Ñ: ${monitoringDuration.toFixed(2)}ms`)
    
    return getSummaryReport()
  }

  /**
   * API Ìò∏Ï∂ú ÏÑ±Îä• Ï∏°Ï†ï (ÏµúÏ†ÅÌôîÎêú Î≤ÑÏ†Ñ)
   */
  function measureApiCall(apiName, apiFunction, ...args) {
    // Î™®ÎãàÌÑ∞ÎßÅÏù¥ ÎπÑÌôúÏÑ±ÌôîÎêú Í≤ΩÏö∞ ÏßÅÏ†ë Ïã§Ìñâ
    if (!isMonitoring.value) {
      return apiFunction(...args)
    }

    return new Promise(async (resolve, reject) => {
      const startTime = performance.now()
      const startMemory = performance.memory ? performance.memory.usedJSHeapSize : 0
      
      try {
        // Î°úÍπÖ ÏµúÏÜåÌôî
        if (console.debug) console.debug(`üåê [Performance] API Ìò∏Ï∂ú: ${apiName}`)
        
        const result = await apiFunction(...args)
        
        const endTime = performance.now()
        const endMemory = performance.memory ? performance.memory.usedJSHeapSize : 0
        const duration = endTime - startTime
        const memoryDiff = endMemory - startMemory
        
        // API Ìò∏Ï∂ú Îç∞Ïù¥ÌÑ∞ Í∏∞Î°ù (Í∞ÑÏÜåÌôî)
        const apiCallData = {
          name: apiName,
          duration: duration,
          success: true,
          timestamp: Date.now() // ISO Î¨∏ÏûêÏó¥ ÎåÄÏã† Ïà´Ïûê ÏÇ¨Ïö©
        }
        
        performanceData.apiCalls.push(apiCallData)
        
        // 50Í∞ú Ïù¥ÏÉÅ ÎàÑÏ†ÅÎêòÎ©¥ Ïò§ÎûòÎêú Í≤ÉÎ∂ÄÌÑ∞ Ï†úÍ±∞ (Î©îÎ™®Î¶¨ Ï†àÏïΩ)
        if (performanceData.apiCalls.length > 50) {
          performanceData.apiCalls.shift()
        }
        
        resolve(result)
      } catch (error) {
        const endTime = performance.now()
        const duration = endTime - startTime
        
        // Ïã§Ìå®Ìïú API Ìò∏Ï∂úÎèÑ Í∏∞Î°ù (Í∞ÑÏÜåÌôî)
        const apiCallData = {
          name: apiName,
          duration: duration,
          success: false,
          timestamp: Date.now()
        }
        
        performanceData.apiCalls.push(apiCallData)
        
        // 50Í∞ú Ïù¥ÏÉÅ ÎàÑÏ†ÅÎêòÎ©¥ Ïò§ÎûòÎêú Í≤ÉÎ∂ÄÌÑ∞ Ï†úÍ±∞
        if (performanceData.apiCalls.length > 50) {
          performanceData.apiCalls.shift()
        }
        
        console.error(`‚ùå [Performance] API Ìò∏Ï∂ú Ïã§Ìå®: ${apiName} (${duration.toFixed(2)}ms)`, error)
        
        reject(error)
      }
    })
  }

  /**
   * Î†åÎçîÎßÅ ÏÑ±Îä• Ï∏°Ï†ï
   */
  function measureRender(componentName, renderFunction) {
    const startTime = performance.now()
    
    try {
      const result = renderFunction()
      
      const endTime = performance.now()
      const duration = endTime - startTime
      
      const renderData = {
        component: componentName,
        startTime: startTime,
        endTime: endTime,
        duration: duration,
        timestamp: new Date().toISOString()
      }
      
      if (isMonitoring.value) {
        performanceData.renderTimes.push(renderData)
      }
      
      if (duration > 16.67) { // 60fps Í∏∞Ï§Ä (16.67ms)
        console.warn(`‚ö†Ô∏è [Performance] ÎäêÎ¶∞ Î†åÎçîÎßÅ: ${componentName} (${duration.toFixed(2)}ms)`)
      }
      
      return result
    } catch (error) {
      console.error(`‚ùå [Performance] Î†åÎçîÎßÅ Ïò§Î•ò: ${componentName}`, error)
      throw error
    }
  }

  /**
   * ÏÇ¨Ïö©Ïûê ÏÉÅÌò∏ÏûëÏö© ÏÑ±Îä• Ï∏°Ï†ï
   */
  function measureUserInteraction(interactionName, interactionFunction, ...args) {
    return new Promise(async (resolve, reject) => {
      const startTime = performance.now()
      
      try {
        console.log(`üëÜ [Performance] ÏÇ¨Ïö©Ïûê ÏÉÅÌò∏ÏûëÏö© ÏãúÏûë: ${interactionName}`)
        
        const result = await interactionFunction(...args)
        
        const endTime = performance.now()
        const duration = endTime - startTime
        
        const interactionData = {
          name: interactionName,
          startTime: startTime,
          endTime: endTime,
          duration: duration,
          timestamp: new Date().toISOString(),
          success: true
        }
        
        if (isMonitoring.value) {
          performanceData.userInteractions.push(interactionData)
        }
        
        if (duration > 100) { // 100ms Ïù¥ÏÉÅÏù¥Î©¥ ÎäêÎ¶∞ ÏÉÅÌò∏ÏûëÏö©
          console.warn(`‚ö†Ô∏è [Performance] ÎäêÎ¶∞ ÏÉÅÌò∏ÏûëÏö©: ${interactionName} (${duration.toFixed(2)}ms)`)
        } else {
          console.log(`‚úÖ [Performance] ÏÉÅÌò∏ÏûëÏö© ÏôÑÎ£å: ${interactionName} (${duration.toFixed(2)}ms)`)
        }
        
        resolve(result)
      } catch (error) {
        const endTime = performance.now()
        const duration = endTime - startTime
        
        const interactionData = {
          name: interactionName,
          startTime: startTime,
          endTime: endTime,
          duration: duration,
          timestamp: new Date().toISOString(),
          success: false,
          error: error.message
        }
        
        if (isMonitoring.value) {
          performanceData.userInteractions.push(interactionData)
        }
        
        console.error(`‚ùå [Performance] ÏÉÅÌò∏ÏûëÏö© Ïã§Ìå®: ${interactionName} (${duration.toFixed(2)}ms)`, error)
        
        reject(error)
      }
    })
  }

  /**
   * Î©îÎ™®Î¶¨ ÏÇ¨Ïö©Îüâ Í∏∞Î°ù
   */
  function recordMemoryUsage() {
    if (!performance.memory || !isMonitoring.value) return
    
    const memoryData = {
      used: Math.round(performance.memory.usedJSHeapSize / 1024 / 1024), // MB
      total: Math.round(performance.memory.totalJSHeapSize / 1024 / 1024), // MB
      limit: Math.round(performance.memory.jsHeapSizeLimit / 1024 / 1024), // MB
      timestamp: new Date().toISOString()
    }
    
    performanceData.memoryUsage.push(memoryData)
    
    // Î©îÎ™®Î¶¨ ÏÇ¨Ïö©ÎüâÏù¥ ÎÜíÏúºÎ©¥ Í≤ΩÍ≥†
    const memoryUsagePercent = (memoryData.used / memoryData.limit) * 100
    if (memoryUsagePercent > 80) {
      console.warn(`‚ö†Ô∏è [Performance] ÎÜíÏùÄ Î©îÎ™®Î¶¨ ÏÇ¨Ïö©Îüâ: ${memoryData.used}MB (${memoryUsagePercent.toFixed(1)}%)`)
    }
  }

  /**
   * ÏÑ±Îä• ÏöîÏïΩ ÏóÖÎç∞Ïù¥Ìä∏
   */
  function updateSummary() {
    const apiCalls = performanceData.apiCalls
    const renderTimes = performanceData.renderTimes
    const userInteractions = performanceData.userInteractions
    
    // API Ìò∏Ï∂ú ÏöîÏïΩ
    if (apiCalls.length > 0) {
      const successfulCalls = apiCalls.filter(call => call.success)
      const totalApiTime = successfulCalls.reduce((sum, call) => sum + call.duration, 0)
      
      performanceData.summary.totalApiCalls = apiCalls.length
      performanceData.summary.avgApiTime = totalApiTime / successfulCalls.length
      performanceData.summary.slowestApi = successfulCalls.reduce((slowest, current) => 
        current.duration > (slowest?.duration || 0) ? current : slowest, null)
    }
    
    // Î†åÎçîÎßÅ ÏöîÏïΩ
    if (renderTimes.length > 0) {
      const totalRenderTime = renderTimes.reduce((sum, render) => sum + render.duration, 0)
      
      performanceData.summary.totalRenders = renderTimes.length
      performanceData.summary.avgRenderTime = totalRenderTime / renderTimes.length
    }
    
    // ÏÇ¨Ïö©Ïûê ÏÉÅÌò∏ÏûëÏö© ÏöîÏïΩ
    if (userInteractions.length > 0) {
      const successfulInteractions = userInteractions.filter(interaction => interaction.success)
      const totalInteractionTime = successfulInteractions.reduce((sum, interaction) => sum + interaction.duration, 0)
      
      performanceData.summary.totalInteractions = userInteractions.length
      performanceData.summary.avgInteractionTime = totalInteractionTime / successfulInteractions.length
    }
  }

  /**
   * ÏÑ±Îä• Î≥¥Í≥†ÏÑú ÏÉùÏÑ±
   */
  function getSummaryReport() {
    updateSummary()
    
    const report = {
      monitoringDuration: performance.now() - monitoringStartTime.value,
      apiPerformance: {
        totalCalls: performanceData.summary.totalApiCalls,
        avgTime: performanceData.summary.avgApiTime,
        slowestCall: performanceData.summary.slowestApi,
        callsPerSecond: performanceData.summary.totalApiCalls / ((performance.now() - monitoringStartTime.value) / 1000)
      },
      renderPerformance: {
        totalRenders: performanceData.summary.totalRenders,
        avgTime: performanceData.summary.avgRenderTime,
        fps: 1000 / performanceData.summary.avgRenderTime // Ï∂îÏ†ï FPS
      },
      interactionPerformance: {
        totalInteractions: performanceData.summary.totalInteractions,
        avgTime: performanceData.summary.avgInteractionTime
      },
      memoryUsage: {
        samples: performanceData.memoryUsage.length,
        peak: performanceData.memoryUsage.length > 0 ? Math.max(...performanceData.memoryUsage.map(m => m.used)) : 0,
        current: performance.memory ? Math.round(performance.memory.usedJSHeapSize / 1024 / 1024) : 0
      }
    }
    
    console.log('üìä [Performance] ÏÑ±Îä• Î≥¥Í≥†ÏÑú:', report)
    
    return report
  }

  /**
   * ÏÉÅÏÑ∏ ÏÑ±Îä• Î°úÍ∑∏ Ï∂úÎ†•
   */
  function printDetailedReport() {
    console.group('üìä [Performance] ÏÉÅÏÑ∏ ÏÑ±Îä• Î≥¥Í≥†ÏÑú')
    
    console.group('üåê API Ìò∏Ï∂ú')
    performanceData.apiCalls.forEach((call, index) => {
      const status = call.success ? '‚úÖ' : '‚ùå'
      console.log(`${status} ${index + 1}. ${call.name}: ${call.duration.toFixed(2)}ms`)
    })
    console.groupEnd()
    
    console.group('üé® Î†åÎçîÎßÅ')
    performanceData.renderTimes.forEach((render, index) => {
      const status = render.duration > 16.67 ? '‚ö†Ô∏è' : '‚úÖ'
      console.log(`${status} ${index + 1}. ${render.component}: ${render.duration.toFixed(2)}ms`)
    })
    console.groupEnd()
    
    console.group('üëÜ ÏÇ¨Ïö©Ïûê ÏÉÅÌò∏ÏûëÏö©')
    performanceData.userInteractions.forEach((interaction, index) => {
      const status = interaction.success ? (interaction.duration > 100 ? '‚ö†Ô∏è' : '‚úÖ') : '‚ùå'
      console.log(`${status} ${index + 1}. ${interaction.name}: ${interaction.duration.toFixed(2)}ms`)
    })
    console.groupEnd()
    
    if (performanceData.memoryUsage.length > 0) {
      console.group('üíæ Î©îÎ™®Î¶¨ ÏÇ¨Ïö©Îüâ')
      const latestMemory = performanceData.memoryUsage[performanceData.memoryUsage.length - 1]
      const peakMemory = Math.max(...performanceData.memoryUsage.map(m => m.used))
      console.log(`ÌòÑÏû¨: ${latestMemory.used}MB`)
      console.log(`ÏµúÎåÄ: ${peakMemory}MB`)
      console.log(`ÏÉòÌîå Ïàò: ${performanceData.memoryUsage.length}`)
      console.groupEnd()
    }
    
    console.groupEnd()
  }

  /**
   * ÏÑ±Îä• Îç∞Ïù¥ÌÑ∞ ÎÇ¥Î≥¥ÎÇ¥Í∏∞ (JSON)
   */
  function exportPerformanceData() {
    const exportData = {
      timestamp: new Date().toISOString(),
      monitoringDuration: performance.now() - monitoringStartTime.value,
      browserInfo: {
        userAgent: navigator.userAgent,
        vendor: navigator.vendor,
        platform: navigator.platform
      },
      performanceData: {
        apiCalls: performanceData.apiCalls,
        renderTimes: performanceData.renderTimes,
        userInteractions: performanceData.userInteractions,
        memoryUsage: performanceData.memoryUsage,
        summary: performanceData.summary
      }
    }
    
    const dataStr = JSON.stringify(exportData, null, 2)
    const dataBlob = new Blob([dataStr], { type: 'application/json' })
    const url = URL.createObjectURL(dataBlob)
    
    const link = document.createElement('a')
    link.href = url
    link.download = `performance-report-${new Date().toISOString().replace(/[:.]/g, '-')}.json`
    link.click()
    
    URL.revokeObjectURL(url)
    
    console.log('üìÅ [Performance] ÏÑ±Îä• Îç∞Ïù¥ÌÑ∞ ÎÇ¥Î≥¥ÎÇ¥Í∏∞ ÏôÑÎ£å')
  }

  return {
    // ÏÉÅÌÉú
    performanceData,
    isMonitoring,
    
    // Î©îÏÑúÎìú
    startMonitoring,
    stopMonitoring,
    measureApiCall,
    measureRender,
    measureUserInteraction,
    recordMemoryUsage,
    getSummaryReport,
    printDetailedReport,
    exportPerformanceData
  }
}